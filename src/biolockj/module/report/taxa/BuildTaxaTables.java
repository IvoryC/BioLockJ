/**
 * @UNCC Fodor Lab
 * @author Michael Sioda
 * @email msioda@uncc.edu
 * @date Dec 28, 2018
 * @disclaimer This code is free software; you can redistribute it and/or modify it under the terms of the GNU General
 * Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any
 * later version, provided that any use properly credits the author. This program is distributed in the hope that it
 * will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU General Public License for more details at http://www.gnu.org *
 */
package biolockj.module.report.taxa;

import java.io.*;
import java.util.*;
import biolockj.Config;
import biolockj.Constants;
import biolockj.Log;
import biolockj.api.ApiModule;
import biolockj.module.io.ModuleOutput;
import biolockj.module.report.otu.OtuCountModule;
import biolockj.util.*;

/**
 * Many R BioModules expect separate tables containing log-normalized taxa counts for each taxonomy level. This module
 * reads the most recent OTU count files generated by any previous BioModule.
 * 
 * @blj.web_desc Build Taxa Tables
 */
public class BuildTaxaTables extends OtuCountModule implements ApiModule {

	@Override
	public String getSummary() throws Exception {
		return super.getSummary() + this.summary;
	}

	@Override
	public void runModule() throws Exception {
		buildTaxonomyTables( OtuUtil.getSampleOtuCounts( getInputFiles() ) );
	}

	/**
	 * Build taxonomy tables from the sampleTaxaCounts.
	 *
	 * @param sampleOtuCounts TreeMap(SampleId, TreeMap(OTU, count)) OTU counts for every sample
	 * @throws Exception if errors occur
	 */
	protected void buildTaxonomyTables( final TreeMap<String, TreeMap<String, Long>> sampleOtuCounts )
		throws Exception {
		final String label = "OTUs";
		final int pad = SummaryUtil.getPad( label ) + 4;

		final TreeSet<String> otus = OtuUtil.findUniqueOtus( sampleOtuCounts );
		Log.info( getClass(), "Write " + otus.size() + " unique OTUs for: " + sampleOtuCounts.size() + " samples" );
		report( "OTU Count", sampleOtuCounts );
		report( "Unique OTU", otus );
		this.summary += BioLockJUtil.addTrailingSpaces( "# Samples:", pad ) +
			BioLockJUtil.formatNumericOutput( new Integer( sampleOtuCounts.size() ).longValue(), false ) + RETURN;
		long totalOtus = 0;
		boolean topLevel = true;
		for( final String level: TaxaUtil.getTaxaLevels() ) {
			final TreeSet<String> levelTaxa = TaxaUtil.findUniqueTaxa( otus, level );
			final TreeMap<String, TreeMap<String, Long>> levelTaxaCounts =
				TaxaUtil.getLevelTaxaCounts( sampleOtuCounts, level );
			final Map<String, Long> uniqueOtus = new HashMap<>();

			uniqueOtus.put( level, new Integer( levelTaxa.size() ).longValue() );
			report( "Taxonomy Counts @" + level, levelTaxaCounts );
			final File table = getTaxonomyTableFile( getOutputDir(), level, null );
			Log.info( getClass(), "Building: " + table.getAbsolutePath() );

			final BufferedWriter writer = new BufferedWriter( new FileWriter( table ) );
			try {
				writer.write( MetaUtil.getID() );
				for( final String taxa: levelTaxa )
					writer.write( TAB_DELIM + taxa );
				writer.write( RETURN );

				for( final String sampleId: sampleOtuCounts.keySet() ) {
					final TreeMap<String, Long> taxaCounts = levelTaxaCounts.get( sampleId );
					if( taxaCounts.isEmpty() ) {
						Log.warn( getClass(), "No " + level + " taxa found: " + sampleId );
						continue;
					}
					writer.write( sampleId );

					for( final String taxa: levelTaxa ) {
						Long count = 0L;
						if( taxaCounts.keySet().contains( taxa ) ) {
							count = taxaCounts.get( taxa );
							if( topLevel ) totalOtus += count;
						}

						writer.write( TAB_DELIM + count );
						Log.debug( getClass(), sampleId + ":" + taxa + "=" + count );
					}

					writer.write( RETURN );
				}

				this.summary += BioLockJUtil.addTrailingSpaces( "# Unique " + level + " OTUs:", pad ) +
					BioLockJUtil.formatNumericOutput( uniqueOtus.get( level ), false ) + RETURN;
			} finally {
				writer.close();
			}
			topLevel = false;
		}

		this.summary += BioLockJUtil.addTrailingSpaces( "# Total OTUs:", pad ) +
			BioLockJUtil.formatNumericOutput( totalOtus, false );
	}

	private void report( final String label, final Collection<String> col ) {
		if( Log.doDebug() ) for( final String item: col )
			Log.debug( getClass(), "REPORT [ " + label + " ]:" + item );
	}

	private void report( final String label, final TreeMap<String, TreeMap<String, Long>> map ) {
		if( Log.doDebug() ) for( final String id: map.keySet() ) {
			final TreeMap<String, Long> innerMap = map.get( id );
			for( final String otu: innerMap.keySet() )
				Log.debug( getClass(), "REPORT [ " + id + " " + label + " ]: " + otu + "=" + innerMap.get( otu ) );
		}
	}

	private String summary = "";

	@Override
	public String getDescription() {
		return "Convert OTU-tables split by sample into taxa tables split by level.";
	}
	
	@Override
	public String getDetails() {
		return "Each classifier module has a parser module that converts the classifier-specific output format into a common OTU table format. This module merges those tables from all samples, and splits the tables by taxonomic level.";
	}

	@Override
	public String getCitationString() {
		return "Module developed by Mike Sioda" + System.lineSeparator()
		+ "BioLockJ " + BioLockJUtil.getVersion();
	}

	/**
	 * Create File object of a taxonomy table at the given level, with the given suffix, in the given directory dir.
	 * 
	 * @param dir Target directory
	 * @param level Taxonomy level
	 * @param suffix File suffix
	 * @return Taxonomy Table File
	 * @throws Exception if errors occur
	 */
	private File getTaxonomyTableFile( final File dir, final String level, final String suffix )
		throws Exception { // Replace Exception with new TaxaTableException
		if( level == null ) throw new Exception( "Level is required to build a taonomy table" );
		String mySuffix = suffix;
		if( mySuffix != null && !mySuffix.endsWith( "_" ) ) mySuffix += "_";
		if( mySuffix != null && !mySuffix.startsWith( "_" ) ) mySuffix = "_" + mySuffix;
		if( mySuffix == null ) mySuffix = "_";
		return new File( dir.getAbsolutePath() + File.separator + Config.pipelineName() + "_" + TaxaTable.TAXA_TABLE + mySuffix +
			level + Constants.TSV_EXT );
	}

	@Override
	public List<ModuleOutput> getOutputTypes(){
		List<ModuleOutput> outputs = new ArrayList<>();
		outputs.add( new ModuleOutput(this, "A taxa table that is merged result of all input OTU tables.", new TaxaTable()) );
		return outputs;
	}

}
